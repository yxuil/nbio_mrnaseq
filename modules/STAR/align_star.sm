# STAR_IDX = [os.path.join(config['ref_base'], "STARIndex/{}").format(f) for f in "chrLength.txt chrNameLength.txt chrName.txt chrStart.txt Genome genomeParameters.txt SA SAindex".split()]
#
# rule align_with_star:
#     input:
#         ref = STAR_IDX,
#         reads = lambda wc: ["trimmed_fq/{}_R1.fq.gz".format(wc.sample), "trimmed_fq/{}_R2.fq.gz".format(wc.sample)] if is_paired(wc.sample) else "trimmed_fq/{}.fq.gz".format(wc.sample)
#     output:
#         genome_alignment="tmp/star_alignment/{sample}_Aligned.sortedByCoord.out.bam",
#         transcriptome_alignment = "tmp/star_alignment/{sample}_Aligned.toTranscriptome.out.bam",
#         log="logs/star_align_{sample}.final.log"
#     params:
#         mem = "32G", # for SGE submission option: -l vf={params.mem}
#         idx_dir = os.path.join(config['ref_base'], "STARIndex"),
#         o_prefix = "tmp/star_alignment/{sample}_",
#         reads_lst = lambda wc: "trimmed_fq/{s}_R1.fq.gz trimmed_fq/{s}_R2.fq.gz".format(s = wc.sample) if is_paired(wc.sample) else "trimmed_fq/{}.fq.gz".format(wc.sample)
#     log: "shell_logs/star_align_{sample}.log"
#     threads: 8
#
#     message: "\n#    Align sample {wildcards.sample} to reference genome"
#
#     shell:"""
#         # if [ -z "$SGE_O_WORKDIR" ]; then
#         #     logging="2>&1 | tee {log}" # shell logging
#         # else
#         #     logging=""  # SGE logging
#         # fi
#         {STAR} --runThreadN {threads} --genomeDir {params.idx_dir} --readFilesIn {params.reads_lst}  \
#             --genomeLoad LoadAndKeep
#             --readFilesCommand zcat --outFileNamePrefix {params.o_prefix} --outSAMattributes NH HI AS NM MD XS \
#             --outSAMunmapped Within --outSAMtype BAM SortedByCoordinate --quantMode TranscriptomeSAM \
#             --outFilterMultimapNmax 50 #$logging
#         mv {params.o_prefix}Log.final.out {output.log}
#         """

read_length=100 # TODO add parameter in the config, then use int(config["read_length"]) - 1
STAR_IDX_DIR = "ref/STARIndex"
STAR_IDX = [STAR_IDX_DIR + "/{}".format(f) for f in \
                  "chrLength.txt chrNameLength.txt chrName.txt chrStart.txt Genome genomeParameters.txt SA SAindex".split()]
rule star_index:
    input:
        fa = ref_fa, #os.path.join(ref_base, "genome.fa"),
        gtf= ref_gtf #os.path.join(ref_base, "annotation", "genes.gtf")
    output: STAR_IDX
    log: "shell_logs/star_index_pass1.log"
    params:
        mem="30G",
    threads: 8
    message: """\n##### Create STAR reference genome index with known gene annotation
    # rule: star_index
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM: STAR genomeGenerate
    """
    shell: " {STAR} --runThreadN {threads} --runMode genomeGenerate --genomeDir {STAR_IDX_DIR} " \
           "--genomeFastaFiles {input.fa} --sjdbGTFfile {input.gtf} --sjdbOverhang {read_length}"

rule star_align_pass1:
    input:
        ref = STAR_IDX,
        reads = lambda wc: ["trimmed_fq/{}_R1.fq.gz".format(wc.sample), "trimmed_fq/{}_R2.fq.gz".format(wc.sample)] if is_paired(wc.sample) else "trimmed_fq/{}.fq.gz".format(wc.sample)
    output:
        junction = "tmp/star_alignment_pass1/{sample}_SJ.out.tab"
    params:
        mem = "32G", # for SGE submission option: -l vf={params.mem}
        o_prefix = "tmp/star_alignment_pass1/{sample}_",
        reads_lst = lambda wc: "trimmed_fq/{s}_R1.fq.gz trimmed_fq/{s}_R2.fq.gz".format(s = wc.sample) if is_paired(wc.sample) else "trimmed_fq/{}.fq.gz".format(wc.sample)
    log: "shell_logs/star_align_{sample}.log"
    threads: 8

    message: """\n##### Align PASS1 - align sample {wildcards.sample} to reference genome to generate novel junction list
    # rule: star_align_pass1
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM: STAR
    """

    shell:"""
        {STAR} --runThreadN {threads} --genomeDir {STAR_IDX_DIR} --readFilesIn {params.reads_lst}  \
            --readFilesCommand zcat --outFileNamePrefix {params.o_prefix} --outSAMattributes NH HI AS NM MD XS \
            --outFilterMultimapNmax 50 #$logging
        """


star_junc_merge= srcdir("star_junc_merge.py")
rule merge_star_junction:
    input: expand("tmp/star_alignment_pass1/{s}_SJ.out.tab", s=SAMPLES)
    output: "tmp/star_alignment_pass1/master_SJ.out.tab"
    params:
        mem = "2G"
    log: "shell_logs/star_junc_merge.log"
    message: """\n##### merge output junction files from individual STAR alignment
    # rule: merge_star_junction
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM: star_junc_merge.py
    """
    threads: 1
    shell: "{star_junc_merge} {input} > {output}"

rule star_align_pass2:
    input:
        ref = STAR_IDX,
        reads = lambda wc: ["trimmed_fq/{}_R1.fq.gz".format(wc.sample), "trimmed_fq/{}_R2.fq.gz".format(wc.sample)] if is_paired(wc.sample) else "trimmed_fq/{}.fq.gz".format(wc.sample),
        junc_file = rules.merge_star_junction.output
    output:
        genome_alignment="tmp/star_alignment_pass2/{sample}_Aligned.sortedByCoord.out.bam",
        transcriptome_alignment = "tmp/star_alignment_pass2/{sample}_Aligned.toTranscriptome.out.bam",
        log="logs/star_align_{sample}.final.log"
    params:
        mem = "32G", # for SGE submission option: -l vf={params.mem}
        o_prefix = "tmp/star_alignment_pass2/{sample}_",
        reads_lst = lambda wc: "trimmed_fq/{s}_R1.fq.gz trimmed_fq/{s}_R2.fq.gz".format(s = wc.sample) if is_paired(wc.sample) else "trimmed_fq/{}.fq.gz".format(wc.sample)
    log: "shell_logs/star_align_{sample}.log"
    threads: 8

    message: """\n#####  STAR pass2 align sample {wildcards.sample} to reference genome with newly found multi-sample junctions
    # rule: star_align_pass2
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM: STAR --quantMode TranscriptomeSAM GeneCounts
    """

    shell:"""
        # if [ -z "$SGE_O_WORKDIR" ]; then
        #     logging="2>&1 | tee {log}" # shell logging
        # else
        #     logging=""  # SGE logging
        # fi
        {STAR} --runThreadN {threads} --genomeDir {STAR_IDX_DIR} --sjdbFileChrStartEnd {input.junc_file} \
            --readFilesIn {params.reads_lst}  \
            --readFilesCommand zcat --outFileNamePrefix {params.o_prefix} --outSAMattributes NH HI AS NM MD XS \
            --outSAMunmapped Within --outSAMtype BAM SortedByCoordinate --quantMode TranscriptomeSAM GeneCounts \
            --outFilterMultimapNmax 50 #$logging
        mv {params.o_prefix}Log.final.out {output.log}
        """

rule mv_alignment:
    input:  "tmp/star_alignment_pass2/{sample}_Aligned.sortedByCoord.out.bam",
            "tmp/star_alignment_pass2/{sample}_Aligned.toTranscriptome.out.bam"
    output: "alignments/{sample}_aligned_genome.bam",
            "alignments/{sample}_aligned_transcriptome.bam"
    log: "shell_logs/star_align_{sample}.log"
    params:
        mem = "2G"
    message: """\n#####  Move alignment files to destination
    # rule: mv_alignment
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM: mv
    """
    shell:  "mv  {input[0]} {output[0]};"
            "mv  {input[1]} {output[1]}"

star_report = srcdir("align_star_report.py")
rule alignment_stat:
    input: expand("logs/star_align_{sample}.final.log", sample=SAMPLES)
    output: "alignments/alignment_stat.html"
    params: mem='1G', o_prefix="alignments/alignment_stat"
    log: "shell_logs/trim_report.log"
    message: """\n#####  report STAR alignment stat
    # rule: alignment_stat
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM: align_star_report.py
    """
    shell: """
        {star_report} {config_fn} {params.o_prefix}
        """



# use this rule when only alignments are needed
rule alignment:
    input: expand("alignments/{sample}_aligned_genome.bam", sample=SAMPLES)
    message: """\n##### Run the alignment for all samples
    # rule: alignment
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM:
    """
