'''
This is a quant module, which takes a transcript-aligned BAM file (rsem_bam rule) to produce individual
expression file (temporary); and individual expression are aggregated to feature read count file (rule
make_exp_matrix)

input: alignments/sample_aligned_transcriptome.bam    <- sample is enumerated through those defined in config
output: expression/{exp}_vs_{ctrl}.{feature, gene|isoform}.readcounts.txt
'''

RSEM_IDX_FILES = ["genome.{i}.ebwt".format(i=i) for i in range(1,5)] + ["genome.rev.{i}.ebwt".format(i=i) for i in [1,2]]
RSEM_IDX = [os.path.join(ref_base, "RSEMIndex", fn) for fn in RSEM_IDX_FILES]
RSEM_IDX_DIR = os.path.join(ref_base, "RSEMIndex")
# point RSEM_IDX to project folder if star reference is incomplete
#for fn in RSEM_IDX:
#    if not os.path.isfile(fn):
#        RSEM_IDX = [os.path.join("tmp", "ref", "RSEMIndex", fn) for fn in RSEM_IDX_FILES]
#        RSEM_IDX_DIR = os.path.join("tmp", "ref", "RSEMIndex")
#        break

##### INDEX #####


def clean_GTF(gtf_fn, output_fn):
    valid_gtf_records = {}
    trx_id_lst = []
    dup_gtf_records = {}

    with open(gtf_fn, 'r') as gtf_in:
        for line in gtf_in:
            fields = line.strip().split('\t')

            if len(fields[0]) > 5: continue # skip non 'chrXX' lines
            trx_id = fields[-1].split(";")[1].split('"')[1] # gene_id "NM_032291"; transcript_id "NM_032291";
            if trx_id not in valid_gtf_records: # make a new trx entry if it is not exist yet
                valid_gtf_records[trx_id] = {'transcript_id': trx_id,
                                             'chr': fields[0],
                                             'strand': fields[6],
                                             'GTF': []}
                trx_id_lst.append(trx_id) # for late use to keep the GTF records in the same order

            if valid_gtf_records[trx_id]['chr'] != fields[0] or valid_gtf_records[trx_id]['strand'] != fields[6]:
                # same trx_id on other chromosome
                if trx_id not in dup_gtf_records:
                    dup_gtf_records[trx_id] = {'transcript_id': trx_id,
                                             'chr': fields[0],
                                             'strand': fields[6],
                                             'GTF': []}
                dup_gtf_records[trx_id]['GTF'].append(line)
            else:
                valid_gtf_records[trx_id]['GTF'].append(line)

    with open(output_fn, 'w') as gtf_out:
        for trx_id in trx_id_lst:
            gtf_out.writelines(valid_gtf_records[trx_id]['GTF'])
    with open("tmp/dup.gtf", 'w') as dup_out:
        for trx_id in trx_id_lst:
            if trx_id in dup_gtf_records:
                dup_out.writelines(dup_gtf_records[trx_id]['GTF'])

#rule fix_gtf:
#    input: ref_gtf #os.path.join(ref_base, "annotation", "genes.gtf")
#    output: "tmp/genes_cleaned.gtf"
#    log: "shell_logs/reference_fix_gtf.log"
#    params:
#        mem="1G"
#    run: clean_GTF(input[0], output[0])

#
# rule link_ref:
#     input: ref_dir + "./genome.fa"
#     output: ref_dir + "./RSEMIndex/genome.fa"
#     shell: "ln -sf {input} {output}\n touch {output}"

rule rsem_index:
    input:
        fa = ref_fa, #os.path.join(ref_base, "genome.fa"),
        gtf= ref_gtf #"tmp/genes_cleaned.gtf"
    output: RSEM_IDX
    log: "tmp/shell_log/reference_index.log"
    params:
        mem = "2G",
        ref = os.path.join(RSEM_IDX_DIR, "genome")
    message: """\n##### Make RSEM index with reference sequence and gene annotation
    # rule: rsem_index
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM: rsem-prepare-reference
    """
    shell:
        "{RSEM}/rsem-prepare-reference --gtf {input.gtf} --bowtie --bowtie-path {BOWTIE} {input.fa} {params.ref};"

ruleorder: rsem_bam > rsem_fastq
rule rsem_bam:
    input:
        ref = RSEM_IDX,
        bam  = "alignments/{sample}_aligned_transcriptome.bam"
    output:"tmp/rsem_estimate/{sample}.{feature, gene|isoform}s.results"
    log: "tmp/shell_log/rsem_estimate_{sample}.log"
    threads: 8
    params:
        mem = "10G",
        ref= os.path.join(RSEM_IDX_DIR, "genome"),
        prefix= "tmp/rsem_estimate/{sample}",
        pair_option=lambda wildcards: "--paired-end" if isPairedReads(wildcards.sample) else ""
    # message: """\n##### RSEM estimates expression from sample {wildcards.sample} aligned BAM file
    # # rule: rsem_bam
    # # INPUT:   {input}
    # # OUTPUT:  {output}
    # # PROGRAM: rsem-calculate-expression
    # """
    shell: """
            {RSEM}/rsem-calculate-expression {params.pair_option} --bam {input.bam} --no-bam-output -p {threads} {params.ref} {params.prefix}
            """

rule rsem_exp_matrix:
    input: lambda wc: ["expression/{s}_{f}_table.txt".format(s=sample, f=wc.feature) for sample in \
                       config["treatments"][wc.exp] + config["treatments"][wc.ctrl] ]
    output: "expression/{exp}_vs_{ctrl}.{feature, gene|isoform}.readcounts.txt"
    log: "tmp/shell_log/{exp}_vs_{ctrl}.{feature}_cntMat.log"
    params:
        mem = "1G",
        header_str = lambda wildcards: "\t".join([""] + config["treatments"][wildcards.exp] + config["treatments"][wildcards.ctrl])
    message: """\n##### Merging reads count for {wildcards.exp}_vs_{wildcards.ctrl}.{wildcards.feature} data matrix
    # rule: rsem_exp_matrix
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM: rsem-generate-data-matrix
    """
    shell: """
             {RSEM}/rsem-generate-data-matrix {input} > {output}
             sed -i '1s/.*/{params.header_str}/' {output}
             """

rule mv_expression:
    input:  "tmp/rsem_estimate/{sample}.{feature}s.results"
    output: "expression/{sample}_{feature, gene|isoform}_table.txt"
    log: "tmp/shell_log/rsem_estimate_{sample}.log"
    params:
        mem = "1G"
#    message: """\n##### move expression estimation to destination
#    # rule: mv_expression
#    # INPUT:   {input}
#    # OUTPUT:  {output}
#    # PROGRAM: mv
#    """
    shell: "mv {input} {output}"

rsem_write_exp = srcdir("quant_rsem_write_expTable.py")
rule expression_table:
    input: ["expression/%s_{feature}_table.txt" % (sample,) for sample in SAMPLES]
    output: ["expression/{feature, gene|isoform}_%s_table.txt" % (measure,) for measure in ["FPKM", "TPM", "count"] ]
    log: "tmp/shell_log/merge_rsem_{feature}_expression.log"
    message: """\n##### merge all sample {wildcards.feature} expression to count, TPM, and FPKM tables
    # rule: expression_table
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM: quant_rsem_write_expTable.py
    """
    params:
        mem = "1G"
    shell: """
        {rsem_write_exp} {config_fn} {wildcards.feature}
        """

rule report_rsem_expression:
    input: expand("expression/{feature}_{measure}_table.txt", feature = config["features"], measure = ["FPKM", "TPM", "count"])
    output: "expression/exp_report.html"
    log: "tmp/shell_log/exp_report.log"
    # message: "#   merge all sample {wildcards.feature} expression to {output}"
    params:
        mem = "1G"
    run:
        import pandas as pd
        from jinja2 import Template
        labels = list(map(lambda x: " ".join(x.split("/")[1].split("_")[:2]), input))
        grid_js, gt_divs = table_to_html(list(input))

        html_template = Template("""

        <div class=tabs>
            {% for lbl, gt_tbl in labeled_gt %}
            <div id=tab-{{ loop.index }}> <a href="#tab-{{ loop.index }}">{{ lbl }}</a>
                {{ gt_tbl }}
            </div>
            {% endfor %}
        </div>

        <link rel="stylesheet" href="http://cdn.pydata.org/bokeh/release/bokeh-0.9.2.min.css" type="text/css" />
        <script type="text/javascript" src="http://cdn.pydata.org/bokeh/release/bokeh-0.9.2.min.js"></script>
        {{ grid_js }}
        """)
        # make the first table checked
        checked =[' checked="checked"'] + ['']*(len(gt_divs)-1)
        html_str = html_template.render(labeled_gt=zip(labels, gt_divs), grid_js=grid_js)
        with open(str(output), 'w') as f_out:
            f_out.write(html_str)


#--bam [--paired-end] input reference_name sample_name

rule rsem_fastq:
    input:
        ref = RSEM_IDX,
        r1 = lambda wc: [ "trimmed_fq/{}-R1.fq.gz".format(wc.sample)]
    output: "rsem_estimate/{sample}.gene.results",
            "rsem_estimate/{sample}.isoform.results",
            "rsem_estimate/{sample}.transcript.sorted.bam",
            "rsem_estimate/{sample}.genome.sorted.bam"
    threads: 8
    log: "tmp/shell_log/rsem_calc_expr_{wc.sample}.log"
    params:
        mem = "8G",
        ref= os.path.join(ref_base, "RSEMIndex", "genome"),
    message: """\n##### Estimate expression from sample {wildcards.sample} RNAseq raw reads
    # rule: rsem_fastq
    # INPUT:   {input}
    # OUTPUT:  {output}
    # PROGRAM: rsem-calculate-expression
    """
    run:
        read1_lst = ",".join(input.r1)
        pair_option, read2_lst = ("--paired-end", ",".join(input.r1).replace("R1", "R2") ) \
                                  if isPairedReads(wildcards.sample) else ("", "")
        shell("{RSEM}/rsem-calculate-expression -p {threads} --output-genome-bam --bowtie-path {BOWTIE} "\
              "{pair_option} {read1_lst} {read2_lst} {params.ref} rsem_estimate/{wildcards.sample};")



rule expression:
    input: expand("expression/{sample}_{feature}_table.txt", sample = SAMPLES, feature = config["features"]),
            expand("expression/{feature}_{measure}_table.txt", feature = config["features"], measure = ["FPKM", "TPM", "count"])
