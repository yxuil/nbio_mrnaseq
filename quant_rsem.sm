'''
This is a quant module, which takes a transcript-aligned BAM file (rsem_bam rule) to produce individual
expression file (temporary); and individual expression are aggregated to feature read count file (rule
make_exp_matrix)

input: alignments/sample_aligned_transcriptome.bam    <- sample is enumerated through those defined in config
output: expression/{exp}_vs_{ctrl}.{feature, genes|isoforms}.counts.matrix
'''

##### RSEM quantification #####

## rsem output files are:
## <sample>.genes.results
## <sample>.isoforms.results
## <sample>..stat
## <sample>..transcript.bam
## <sample>.transcript.sorted.bam
## <sample>.transcript.sorted.bam.bai
RSEM_IDX= [os.path.join(ref_base,  "RSEMIndex", "genome.{i}.ebwt").format(i=i) for i in range(1,5)]\
          +  [os.path.join(ref_base,  "RSEMIndex","genome.rev.{i}.ebwt").format(i=i) for i in [1,2]]

ruleorder: rsem_bam > rsem_fastq
rule rsem_bam:
    input:
        ref = RSEM_IDX,
        bam  = "alignments/{sample}_aligned_transcriptome.bam"
    output:"tmp/rsem_estimate/{sample}.genes.results",
           "tmp/rsem_estimate/{sample}.isoforms.results"
    log: "sge_logs/rsem_estimate_{sample}.log"
    threads: 8
    params:
        mem = "10G",
        ref= ref_base + "/RSEMIndex/genome",
        tmp= "tmp/rsem_estimate/",
        pair_option=lambda wildcards: "--paired-end" if is_paired(wildcards.sample) else ""
    message: "\n#    RSEM estimates expression from sample {wildcards.sample} aligned BAM file"
    shell: """
            # if [ -z "$SGE_O_WORKDIR" ]; then
            #     logging="2>&1 | tee {log}" # shell logging
            # else
            #     logging=""  # SGE logging
            # fi
            {RSEM}/rsem-calculate-expression {params.pair_option} --bam {input.bam} -p {threads} {params.ref} {params.tmp}/{wildcards.sample} #$logging
            """

rule make_exp_matrix:
    input: lambda wc: ["expression/{s}_{f}_table.txt".format(s=sample, f=wc.feature) for sample in \
                       config["treatments"][wc.exp] + config["treatments"][wc.ctrl] ]
    output: "expression/{exp}_vs_{ctrl}.{feature, [a-zA-Z]+}.counts.matrix"
    log: "sge_logs/{exp}_vs_{ctrl}.{feature}_cntMat.log"
    params:
        mem = "1G",
        header_str = lambda wildcards: "\t".join([""] + config["treatments"][wildcards.exp] + config["treatments"][wildcards.ctrl])
    message: "\n    Merging reads count for {wildcards.exp}_vs_{wildcards.ctrl}.{wildcards.feature} data matrix"
    shell: """
             {RSEM}/rsem-generate-data-matrix {input} > {output}
             sed -i '1s/.*/{params.header_str}/' {output}
             """

rule mv_expression:
    input: "tmp/rsem_estimate/{sample}.genes.results",
           "tmp/rsem_estimate/{sample}.isoforms.results"
    output: "expression/{sample}_genes_table.txt",
            "expression/{sample}_isoforms_table.txt"
    log: "sge_logs/rsem_estimate_{sample}.log"
    params:
        mem = "1G"
    message: "#     move expression estimation to destination"
    shell:    "mv {input[0]}  {output[0]}; "
              "mv {input[1]}  {output[1]}"


# rule count_table:
#     input: lambda wc: [ "expression/{sample}_{feature}_table.txt".format(sample=s, feature=wc.feature) for s in SAMPLES ]
#     output: "expression/{feature}_count_table.txt"
#     log: "sge_logs/merge_rsem_{feature}_expression.log"
#     message: "#   merge all sample {wildcards.feature} expression to {output}"
#     params:
#         mem = "1G",
#         header_str = "\t".join([""] + SAMPLES)
#     shell: """
#         {RSEM}/rsem-generate-data-matrix {input} > {output}
#         sed -i '1s/.*/{header_str}/' {output}
#         """

rule expression_table:
    input: lambda wc: [ "expression/{sample}_{feature}_table.txt".format(sample=s, feature=wc.feature) for s in SAMPLES ]
    output: "expression/{feature}_count_table.txt",
            "expression/{feature}_TPM_table.txt",
            "expression/{feature}_FPKM_table.txt"
    log: "sge_logs/merge_rsem_{feature}_expression.log"
    message: "#   merge all sample {wildcards.feature} expression to count, TPM, and FPKM tables"
    params:
        mem = "1G"
    shell: """
        {_pipeline_dir}/quant_rsem_write_expTable.py {cfg_fn} {wildcards.feature}
        """

#--bam [--paired-end] input reference_name sample_name

rule rsem_fastq:
    input:
        ref = RSEM_IDX,
        r1 = lambda wc: [ "trimmed_fq/{}-R1.fq.gz".format(wc.sample)]
    output: "rsem_estimate/{sample}.genes.results",
            "rsem_estimate/{sample}.isoforms.results",
            "rsem_estimate/{sample}.transcript.sorted.bam",
            "rsem_estimate/{sample}.genome.sorted.bam"
    threads: 8
    log: "sge_logs/rsem_calc_expr_{wc.sample}.log"
    params:
        mem = "8G",
        ref= ref_base + "./RSEMIndex/genome"
    message: "\n    Estimate expression from sample {wildcards.sample} RNAseq reads"
    run:
        read1_lst = ",".join(input.r1)
        pair_option, read2_lst = ("--paired-end", ",".join(input.r1).replace("R1", "R2") ) \
                                  if is_paired(wildcards.sample) else ("", "")
        shell("{RSEM}/rsem-calculate-expression -p {threads} --output-genome-bam --bowtie-path {BOWTIE} "\
              "{pair_option} {read1_lst} {read2_lst} {params.ref} rsem_estimate/{wildcards.sample};"
              " mv ")

